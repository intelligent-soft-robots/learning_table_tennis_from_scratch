#!/usr/bin/env python3

import sys
import time
import threading
import pam_mujoco
import o80_pam
import o80
from typing import Tuple, List, cast, Optional, Sequence, Dict
from pathlib import Path
from pynput import keyboard

# not used directly in this code,
# but for evaluating things in the transition file
from collections import OrderedDict
from numpy import array, float32


SHORT_SLEEP: float = 0.25
"""duration of pause when playing a transition """

LONG_SLEEP: float = 1.0
""" duration of pause between two plays of a transition"""

ALGO_TIME_STEP_MS: int = 10
""" time step between the capture of two observations, when running the learning algorithm """

MUJOCO_ID: str = "transitions"
""" mujoco_id of the pam_mujoco instance that should be started before this script is executed"""


Joints = Tuple[float, float, float, float]
"""for 4 dofs robot joints positions and velocities"""

Point3D = Tuple[float, float, float]
"""for the ball 3d position and 3d velocity"""

Pressures = Tuple[
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
]
"""for the set of pressures applied to the robot"""


class Observation:
    """
    All the attribute of an observation (i.e. robot joints
    positions and velocities, ball position and velocity,
    pressures of the muscles.
    """

    def __init__(
        self,
        robot_position: Joints,
        robot_velocity: Joints,
        ball_position: Point3D,
        ball_velocity: Point3D,
        pressures: Pressures,
    ) -> None:
        self.robot_position = robot_position
        self.robot_velocity = robot_velocity
        self.ball_position = ball_position
        self.ball_velocity = ball_velocity
        self.pressures = pressures

    def same_robot_position(self, other) -> bool:
        diff = [abs(a - b) for a, b in zip(self.robot_position, other.robot_position)]
        same = all([d < 0.01 for d in diff])
        return same

    def __str__(self) -> str:
        attrs = (
            "robot_position",
            "robot_velocity",
            "ball_position",
            "ball_velocity",
            "pressures",
        )

        def _str(attr: str) -> str:
            values = cast(Tuple[float, ...], getattr(self, attr))
            values_str: str = (
                attr + ": " + ",".join(["{0:0.2f}".format(v) for v in values])
            )
            return values_str

        return " | ".join(list(map(_str, attrs)))


class Transition:
    """
    Encapsulate two successive observations
    """

    def __init__(
        self,
        timestep: int,
        episode_id: int,
        observation1: Observation,
        observation2: Observation,
    ) -> None:
        self.id: Tuple[int, int] = (timestep, episode_id)
        self.timestep = timestep
        self.episode_id = episode_id
        self.observation1 = observation1
        self.observation2 = observation2

    def get_id(self) -> Tuple[int, int]:
        return self.id

    def same_robot_positions(self, other) -> bool:
        if not self.observation1.same_robot_position(other.observation1):
            return False
        if not self.observation2.same_robot_position(other.observation2):
            return False
        return True

    def __eq__(self, other) -> bool:
        if self.timestep != other.timestep:
            return False
        if self.episode_id != other.episode_id:
            return False
        return True

    def __le__(self, other) -> bool:
        if self.timestep > other.timestep:
            return False
        if self.episode_id > other.episode_id:
            return False
        return True

    def __str__(self) -> str:
        return str(
            "observation 1: "
            + str(self.observation1)
            + "\n"
            + "observation 2: "
            + str(self.observation2)
        )

    @classmethod
    def from_file(cls, path: Path) -> List[object]:
        """
        Parse the file and returns the corresponding list
        of instances of Transition.
        """

        if not path.is_file():
            raise FileNotFoundError("failed to find {}".format(path))

        def _get_observation(observation: Tuple[float, ...]) -> Observation:
            robot_position = observation[0:4]
            robot_velocity = observation[4:8]
            ball_position = observation[16:19]
            ball_velocity = observation[19:22]
            pressures = observation[8:16]
            return Observation(
                robot_position, robot_velocity, ball_position, ball_velocity, pressures
            )

        transitions: List[object] = []

        with open(path, "r") as f:
            s = f.read()
            d = s.split("\n\n")
            for chunk in d[:-1]:
                transitions_ = eval(chunk)
                for criterion, transition, timestep, _, episode_id in transitions_:
                    observation, next_observation, action, _, _, _ = transition
                    observation = tuple(observation["observation"])
                    next_observation = tuple(next_observation["observation"])
                    transitions.append(
                        Transition(
                            timestep,
                            episode_id,
                            _get_observation(observation),
                            _get_observation(next_observation),
                        )
                    )

        return transitions


def group_transitions(
    transitions: Sequence[Transition],
) -> Dict[Tuple[int, int], List[Transition]]:
    """
    Group together all transitions having the same id (i.e. recorded at the
    same episode and the same timestep). Implicitely, the robot position
    encapsulated by the observations of grouped transitions should be the same.
    """
    grouped: Dict[Tuple[int, int], List[Transition]] = {}
    for transition in transitions:
        try:
            grouped[transition.get_id()].append(transition)
        except KeyError:
            grouped[transition.get_id()] = [transition]
    return grouped


def get_frontends(
    mujoco_id: str,
    nb_balls: int,
) -> Tuple[o80_pam.FrontEnd, List[o80_pam.BallFrontEnd]]:
    """
    Returns o80's frontend for the control of the ball and of
    the robot of the pam_mujoco running instance.
    """

    robot = pam_mujoco.MujocoRobot(
        pam_mujoco.RobotType.PAMY2,
        "robot",
        control=pam_mujoco.MujocoRobot.JOINT_CONTROL,
    )

    ball_segment_ids = ["ball_{}".format(index) for index in range(nb_balls)]
    balls = [
        pam_mujoco.MujocoItem(
            segment_id,
            control=pam_mujoco.MujocoItem.CONSTANT_CONTROL,
            color=(1, 0, 0, 1),
        )
        for segment_id in ball_segment_ids
    ]

    table = pam_mujoco.MujocoTable("table")

    graphics = True
    accelerated_time = True
    handle = pam_mujoco.MujocoHandle(
        mujoco_id,
        table=table,
        robot1=robot,
        balls=balls,
        graphics=graphics,
        accelerated_time=accelerated_time,
    )

    robot_frontend: o80_pam.FrontEnd = handle.frontends["robot"]
    ball_frontends: List[o80_pam.BallFrontEnd] = [
        handle.frontends[segment_id] for segment_id in ball_segment_ids
    ]

    return robot_frontend, ball_frontends


class Stopper:
    """
    Encapsulate a boolean, useful for sending
    stop signal to a thread.
    """

    def __init__(self) -> None:
        self.must_stop = False

    def stop(self) -> None:
        self.must_stop = True

    def reset(self) -> None:
        self.must_stop = False


def play_transitions(
    info: str,
    transitions: Sequence[Transition],
    robot: o80_pam.FrontEnd,
    balls: Sequence[o80_pam.BallFrontEnd],
    stopper: Stopper,
    short_sleep,
    long_sleep,
    algo_step_ms,
    out_of_sight: Tuple[float, float, float] = (-10.0, -10.0, -10),
):
    """
    Play the transition in the pam_mujoco instance.
    The transition will be played over and over until
    the stop method of the stopper has been called (this
    function is expected to be called in a thread).

    Parameters
    ----------
    info:
      will be printed in the terminal
    transitions:
      the transitions to be played. They are supposed to
      correspond to the same episode id/ timestep, i.e. to
      have similar observations in regard to the robot positions.
      A ValueError is throw if it is not the case.
    robot:
      o80 frontend to the robot
    balls:
      o80 frontends to the balls. On ball per transition. There should be
      more simulated balls than transitions to display. If not, a ValueError
      is raised.
    stopper:
      should be used to stop the thread
      running this function
    short_sleep:
      pause time when playing the transition
    long_sleep:
      pause time between two plays of the transition
    algo_step_ms:
      time step between two collections of observation
      by the learning algorithm
    out_of_sight (optional):
      3d position where the unused balls will be moved to
    """

    # if not enough balls to play all the transitions, exiting
    if len(balls) < len(transitions):
        raise ValueError(
            "play_transitions: one can not play {} transitions using "
            "only {} balls".format(len(transitions), len(balls))
        )

    # if there are more balls than transitions, hiding the extra balls
    for ball in balls[len(transitions) :]:
        ball.add_command(
            out_of_sight, [0.0] * 3, o80.Duration_us.milliseconds(5), o80.Mode.OVERWRITE
        )
    ball.pulse()

    robot_positions = (
        transitions[0].observation1.robot_position,
        transitions[0].observation2.robot_position,
    )
    ball_positions = [
        (
            transition.observation1.ball_position,
            transition.observation2.ball_position,
        )
        for transition in transitions
    ]
    sleeps = (short_sleep, long_sleep)
    duration = o80.Duration_us.milliseconds(algo_step_ms)
    index = 0
    while not stopper.must_stop:
        robot.add_command(
            robot_positions[index], [0.0] * 4, duration, o80.Mode.OVERWRITE
        )
        for ball, ball_position in zip(balls, ball_positions):
            ball.add_command(
                ball_position[index], [0.0] * 3, duration, o80.Mode.OVERWRITE
            )
        robot.pulse()
        ball.pulse()
        time.sleep(sleeps[index])
        index += 1
        if index == 2:
            index = 0


class TransitionsPlayer:
    """
    For playing transitions in the pam_mujoco instances.
    The transitions that belong to the same episode id and time step are grouped
    and played together

    Parameters
    ----------
    transitions:
      the transitions to be played, grouped by id
      (id: tuple(episode id, timestep))
    robot:
      o80 frontend to the robot
    balls:
      o80 frontends to the balls
    short_sleep:
      pause time when playing the transition
    long_sleep:
      pause time between two plays of the transition
    algo_step_ms:
      time step between two collections of observation
      by the learning algorithm

    """

    def __init__(
        self,
        transitions: List[Tuple[Tuple[int, int], List[Transition]]],
        robot: o80_pam.FrontEnd,
        balls: Sequence[o80_pam.BallFrontEnd],
        short_sleep: float = 1.0,
        long_sleep: float = 3.0,
        algo_ms: int = 10,
    ):
        self._transitions = transitions
        self._robot = robot
        self._balls = balls
        self._short_sleep = short_sleep
        self._long_sleep = long_sleep
        self._algo_ms = algo_ms
        self._index = 0
        self._thread: Optional[threading.Thread] = None
        self._stopper: Stopper = Stopper()

        max_nb_transitions: int = max(
            [len(transitions[1]) for transitions in self._transitions]
        )
        if len(balls) < max_nb_transitions:
            raise ValueError(
                "TransitionsPlayer: frontends to {} balls are provided, but need "
                "at least {}".format(len(balls), max_nb_transitions)
            )

    @classmethod
    def from_file(
        cls,
        path: Path,
        mujoco_id: str,
        short_sleep,
        long_sleep,
        algo_ms,
    ) -> object:
        """
        Parse the file and returns the corresponding instance
        of TransitionsPlayer.
        """
        transitions: List[Transition] = Transition.from_file(path)
        transitions_: Dict[Tuple[int, int], List[Transition]] = group_transitions(
            transitions
        )
        transitions__: List[Tuple[Tuple[int, int], List[Transition]]] = [
            (id_, transitions_[id_]) for id_ in sorted(transitions_.keys())
        ]

        # checking all grouped transitions have the same robot position, if not, exiting
        for id_, transitions in transitions__:
            if len(transitions) > 1:
                for t1, t2 in zip(transitions, transitions[1:]):
                    if not t1.same_robot_positions(t2):
                        error = str(
                            "transitions corresponding episode {} and timestep {} do not all "
                            "have the same robot position. For example:\n"
                            "\tobs1: {}\tobs2: {}\n"
                            "\tobs1: {}\tobs2: {}\n"
                            "\tdiff: {}\tdiff: {}".format(
                                id_[0],
                                id_[1],
                                t1.observation1.robot_position,
                                t1.observation2.robot_position,
                                t2.observation1.robot_position,
                                t2.observation2.robot_position,
                                [
                                    abs(a - b)
                                    for a, b in zip(
                                        t1.observation1.robot_position,
                                        t2.observation1.robot_position,
                                    )
                                ],
                                [
                                    abs(a - b)
                                    for a, b in zip(
                                        t1.observation1.robot_position,
                                        t2.observation1.robot_position,
                                    )
                                ],
                            )
                        )
                        raise ValueError(error)

        max_nb_transitions = max([len(t) for _, t in transitions__])
        robot, balls = get_frontends(mujoco_id, max_nb_transitions)
        return cls(transitions__, robot, balls, short_sleep, long_sleep, algo_ms)

    def size(self) -> int:
        """
        The number of transition that have been parsed.
        """
        return len(self._transitions)

    def _play_transition(self, index: int) -> None:
        """
        Spawns a thread that will play the transitions
        found at the given index over and over.
        """
        if self._thread:
            self._stopper.stop()
            self._thread.join()
            self._stopper.reset()
        self._thread = threading.Thread(
            target=play_transitions,
            args=(
                "episode: {}, timestep: {}".format(
                    self._transitions[index][0][0], self._transitions[index][0][1]
                ),
                self._transitions[index][1],
                self._robot,
                self._balls,
                self._stopper,
                self._short_sleep,
                self._long_sleep,
                self._algo_ms,
            ),
        )
        self._thread.start()

    def play_next(self) -> int:
        """
        Start playing the next transition
        (i.e. index increased by one)
        """
        self._play_transition(self._index)
        played_index = self._index
        self._index += 1
        if self._index >= len(self._transitions):
            self._index = 0
        return played_index

    def play_previous(self) -> int:
        """
        Start playing the previous transition
        (i.e. index decreased by one)
        """
        self._play_transition(self._index)
        played_index = self._index
        self._index -= 1
        if self._index <= 0:
            self._index = len(self._transitions) - 1
        return played_index


def run(
    path: Path, mujoco_id: str, short_sleep: float, long_sleep: float, algo_ms: int
):
    """
    Parse the file and starts playing the related transition in the pam_mujoco instance
    that should have been started previously to the call of this function.

    Parameters
    ----------
    short_sleep:
      pause time when playing the transition
    long_sleep:
      pause time between two plays of the transition
    algo_step_ms:
      time step between two collections of observation
      by the learning algorithm
    """

    player = TransitionsPlayer.from_file(
        path, mujoco_id, short_sleep, long_sleep, algo_ms
    )

    print()
    print("Loaded {} transitions".format(player.size()))
    print()
    print("Select the mujoco window, then press ")
    print("left and right arrows to play previous/next transition")
    print()
    print("Esc to terminate")
    print()

    def on_press(key):
        pass

    def on_release(key):
        if key == keyboard.Key.esc:
            return False
        if key == keyboard.Key.right:
            player.play_next()
        if key == keyboard.Key.left:
            player.play_previous()

    with keyboard.Listener(on_press=on_press, on_release=on_release) as listener:
        listener.join()


if __name__ == "__main__":

    args = sys.argv

    if len(args) == 1:
        print()
        print("USAGE: ")
        print()
        print("in a first terminal:")
        print("pam_mujoco {}".format(MUJOCO_ID))
        print()
        print("then in another terminal:")
        print("hysr_replay_transitions /path/to/transition/file")
        print()
        exit()

    path = Path(args[1])

    run(path, MUJOCO_ID, SHORT_SLEEP, LONG_SLEEP, ALGO_TIME_STEP_MS)
