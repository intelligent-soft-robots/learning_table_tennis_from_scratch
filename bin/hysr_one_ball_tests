#!/usr/bin/env python3

import sys
import time
import random
import math
import o80
import context
import pam_interface
import o80_pam
from lightargs import BrightArgs,FileExists
from learning_table_tennis_from_scratch.hysr_one_ball import HysrOneBall


class global_config:
    o80_pam_time_step = 0.002
    mujoco_time_step = 0.002
    algo_time_step = 0.01
    target_position = [0.45,2.7,0.17]
    reward_normalization_constant = 3.0
    smash_task = False
    rtt_cap = 0.2
    reference_posture = [[14000,22000],[14000,22000],
                         [17000,13000],[14000,16000]]


def ball_other_side(accelerated_time,
                    pam_config,
                    global_config,
                    smash_task):

    hysr = HysrOneBall(accelerated_time,
                       global_config.o80_pam_time_step,
                       global_config.mujoco_time_step,
                       global_config.algo_time_step,
                       global_config.target_position,
                       global_config.reward_normalization_constant,
                       smash_task,
                       rtt_cap=global_config.rtt_cap,
                       trajectory_index=None
                       reference_posture=global_config.reference_posture,
                       pam_config=pam_config)

    hysr.reset()
    frequency_manager = o80.FrequencyManager(1.0/algo_time_step)

    

def execute(accelerated_time,
            pam_config):

    trajectory_index = 49
    print("using ball trajectory file: ",
          context.BallTrajectories().get_file_name(trajectory_index))

    hysr = HysrOneBall(accelerated_time,
                       o80_pam_time_step,
                       mujoco_time_step,
                       algo_time_step,
                       target_position,
                       reward_normalization_constant,
                       smash_task,
                       rtt_cap=rtt_cap,
                       trajectory_index=trajectory_index, # always plays this trajectory (None for random).
                       reference_posture=reference_posture,
                       pam_config=pam_config)

    hysr.reset()
    frequency_manager = o80.FrequencyManager(1.0/algo_time_step)

    # time_switch: duration after episode start after which
    # the robot performs the swing motion
    # manually selected so that sometimes the racket hits the ball,
    # sometimes it does not
    ts = 0.5
    time_switches = []
    while ts<=0.8:
        time_switches.append(ts)
        ts+=0.025

    # converting time switches from seconds to nb of iterations
    iteration_switches = [(1.0/o80_pam_time_step) * ts for ts in time_switches]

    for episode,iteration_switch in enumerate(iteration_switches):

        print("EPISODE",episode,iteration_switch)

        start_robot_iteration = hysr.get_robot_iteration()
        start_ball_iteration = hysr.get_ball_iteration()

        running = True

        while running:

            pressures = swing_posture

            # flatting the pressures
            pressures = [p for sublist in pressures for p in sublist]

            observation,reward,reset = hysr.step(pressures)

            if not accelerated_time:
                waited = frequency_manager.wait()
                if waited<0:
                    print("! warning ! failed to maintain algorithm frequency")

            if reset:
                print("\treward:",reward)

            running = not reset


        hysr.reset()
        frequency_manager = o80.FrequencyManager(1.0/algo_time_step)

    hysr.close()

    
def _configure():
    config = BrightArgs(str("hysr dummy demo using swing motion.\n"+
                            "to be started after start_robots or start_robots_accelerated.\n"+
                            "(in same folder)"))
    config.add_operation("accelerated",
                         "if used, start_robot_accelerated must have been started.")
    config.add_option("pam_config_file",
                      pam_interface.DefaultConfiguration.get_path(),
                      "pam configuration file",
                      str,
                      integrity_checks= [FileExists()])
    change_all=False
    finished  = config.dialog(change_all,sys.argv[1:])
    if not finished:
        return None
    return config


def _run():
    config = _configure()
    if config is None:
        return
    pam_config = pam_interface.JsonConfiguration(config.pam_config_file)
    execute(config.accelerated,
            pam_config)
    

if __name__ == "__main__":
    _run()
